<!DOCTYPE html>
<html>

<head>
    <title>Stream-Up!</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>
    <video id="video" controls preload="auto" width="640" height="264" data-setup='{"controls":true}'>
        <source type='video/mp4' />
    </video>
    <button type="button" class="btn btn-primary" style="margin-left: 10px;" onclick="sendText();">Send</button>
    <div id="messages" class="form-control"></div>

    <script type="text/javascript">
    var video = document.querySelector('video');
    var messages = document.getElementById("messages");

    var queue = [];
    var buffer;

    var totalSegments;
    var segmentLength = 0;
    var segmentDuration = 0;
    var bytesFetched = 0;
    var requestedSegments = [];

    var mediaSource;
    window.MediaSource = window.MediaSource || window.WebKitMediaSource;
    if (!!!window.MediaSource) {
    alert('MediaSource API is not available');
    } else {
        mediaSource = new MediaSource();
        mediaSource.addEventListener('sourceopen', sourceOpen, false);

        video.src = window.URL.createObjectURL(mediaSource);
        video.addEventListener('timeupdate', checkBuffer);
        video.addEventListener('canplay', function () {
            segmentDuration = video.duration / totalSegments;
            video.play();
          });
        video.addEventListener('seeking', seek);

        var webSocket = new WebSocket('ws://localhost:8080/stream');
        webSocket.binaryType = 'arraybuffer';
        webSocket.onmessage = function(event){
            onMessage(event)
        };
        webSocket.onopen = function(event){
            onOpen(event)
        };
        webSocket.onclose = function(event){
            messages.innerHTML += "<br/>" + "Connection closed";
        };
    }

    function sourceOpen (_) {
        video.play();
        buffer = mediaSource.addSourceBuffer('video/mp4;codecs="avc1.64001f,mp4a.40.2"');
        buffer.addEventListener('update', function() { 
            if (queue.length > 0 && !buffer.updating) {
                buffer.appendBuffer(queue.shift());
            }
        });
        console.log('totalSegments:' + totalSegments);
    };
    function checkBuffer (_) {
        var currentSegment = getCurrentSegment();
        if (currentSegment === totalSegments && haveAllSegments()) {
          console.log('last segment', mediaSource.readyState);
          mediaSource.endOfStream();
          video.removeEventListener('timeupdate', checkBuffer);
        } else if (shouldFetchNextSegment(currentSegment)) {
          requestedSegments[currentSegment] = true;
          console.log('time to fetch next chunk', video.currentTime);
          fetchRange(assetURL, bytesFetched, bytesFetched + segmentLength, appendSegment);
        }
    };
    function seek (e) {
        console.log(e);
        if (mediaSource.readyState === 'open') {
          buffer.abort();
          console.log(mediaSource.readyState);
        } else {
          console.log('seek but not open?');
          console.log(mediaSource.readyState);
        }
    };
    function getCurrentSegment () {
        return ((video.currentTime / segmentDuration) | 0) + 1;
    };

    function haveAllSegments () {
        return requestedSegments.every(function (val) { return !!val; });
    };

    function shouldFetchNextSegment (currentSegment) {
        console.log('shouldFetchNextSegment');
        console.log(currentSegment);
        console.log(video.currentTime);
        console.log(segmentDuration);
        console.log(currentSegment);
        console.log(video.currentTime > segmentDuration * currentSegment * 0.8 &&
            !requestedSegments[currentSegment]);
        return video.currentTime > segmentDuration * currentSegment * 0.8 &&
            !requestedSegments[currentSegment];
    };

    function onOpen(event) {
        console.log('onOpen');
        var json = JSON.stringify({
            "type":"text",
            "data":"CONNECTED"
        });
        writeResponse(json);
    }
    function onMessage(event) {
        console.log('onMessage');
        console.log(event);
        if (event.data instanceof ArrayBuffer) {
        console.log('video chunk arrived');
        try {
                if (buffer.updating || queue.length > 0) {
                    queue.push(event.data);
                } else {
                    buffer.appendBuffer(event.data);
                }
            } catch (e) {
                console.log(e);
            }                       		
        } else {
            var message = JSON.parse(event.data);
            if ('totalSegments' == message.key){
                totalSegments = message.value;
                for (var i = 0; i < totalSegments; ++i) requestedSegments[i] = false;
            }
            writeResponse(event.data);
        }
    }

    function sendText(){
        sendMessage("text", null);
    }

    function sendMessage(key, value){
        var json = JSON.stringify({
            "key":key,
            "value":value
        });
        webSocket.send(json);
    }

    function closeSocket(){
        webSocket.close();
    }

    function writeResponse(json){
        var response = JSON.parse(json);
        var output;
        switch (response.key){
            case "text":
                output = response.value;
                break;
            case "image":
                output = "<img src=\'" + response.value + "\'/>"
                break;
        }
        var messages = document.getElementById("messages");
        messages.innerHTML += "<br/>>" + output;
        messages.scrollTop = messages.scrollHeight; 	
    }
        </script>
</body>

</html>